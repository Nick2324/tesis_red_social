\section{Requerimientos no funcionales}
\subsection{Mantenibilidad}

En 1*, los autores hicieron una valoración de las métricas utilizadas para evaluar la mantenibilidad del software, según el estandar ISO/IEC 9126, encontrando deficiencias en la métrica más usa, el Indice de Mantenibilidad, o MI por sus siglas en ingles. Encontradas las deficiencias en claridad, crearon nuevas métricas basados en las subcaracterísticas usadas para medir la mantenibilidad de un software. Las subcaracterísticas atadas a la Mantenibilidad según el estandar son:

\begin{itemize}
 \item \textbf{Analizabilidad (Analisability)}: Se refiere a la dificultad de saber en que parte del software se debe hacer un cambio y, a su vez, cuales tienen deficiencias.
 \item \textbf{Cambiabilidad (Changeability)}: Se refiere al nivel de dificultad para hacer adaptaciones al software.
 \item \textbf{Estabilidad (Stability)}: Compete a este el análisis de cuan estable es el software mientras este está sufriendo algún cambio
 \item \textbf{Probabilidad (Testability)}: Responde a la pregunta, ¿cuán difícil es probar el sistema luego de haberle hecho una modificación?
 \item \textbf{Conformidad de mantenibilidad (Mantenibility conformance)}: Éste se refiere al análisis del cumplimiento de estándares en cuanto a mantenibilidad se refiere.
\end{itemize}

Los autores presentan propiedades del código fuente que serán cruzadas con las subcaracterísticas del estandar ISO/IEC 9126 y, luego, dan las medidas creadas. Ellas son:

\begin{itemize}
 \item \textbf{Volumen}: Cantidad de código del sistema. Mientras más grande es, más difícil es de analizar
 \item \textbf{Complejidad por unidad}: Se refiere a la complejidad requerida por una unidad, esto es, “la pieza de código más pequeña que puede ser ejecutada y probada individualmente”*1, para cumplir su uso.
 \item \textbf{Duplicación}: Se refiere al “código clonado”*, esto es, código repetido muchas veces.
 \item \textbf{Tamaño de unidad}: Se refiere al tamaño de las unidades en un software
 \item \textbf{Prueba de unidad}: Son unidades creadas especialmente para probar otras
\end{itemize}

A continuación se presenta el cruce propiedades/subcaracterísticas:

img1 ** Figura XXX Cruce entre las subcaracterísticas atribuidas a la mantenibilidad del software en el estandar ISO/IEC 9126 y las propiedades a nivel de código. Cada cruce es indicado por una 'x'.

Así, en el presente proyecto, se ha decidido utilizar las siguientes medidas creadas por los autores:
Nivel de complejidad por unidad: El nivel de complejidad es calculado, en primera instancia, calculando la complejidad ciclomática de cada unidad del software, la cual es definida como e – n + 2, donde “n” representa a los nodos del grafo de control de flujo y “e” el número de aristas de dicho grafo(http://cursos.tecmilenio.edu.mx/cursos/at8q3ozr5p/prof/sa/sa09002/anexos/grafo_java, http://www.mccabe.com/pdf/mccabe-nist235r.pdf). Luego de esto, será necesario ubicar cada unidad en un nivel de riesgo. En el siguiente cuadro se podrá observar cómo son valorados los niveles de riesgo:

img2 ** Figura XXX correspondiente al nivel de riesgo en el software presentado por la complejidad ciclomática promedio del sistema. 

Luego de tener dichas cuentas y, además, por cada unidad tener los LOC (Lines of Code: Líneas de Código) asociados, se ubicarán las sumas de los LOC ubicados en cada nivel de riesgo, esto es, sumatoria(LOC subij), donde i representa el cambio en los niveles de riesgo y j representa el cambio en las unidades que pertenecen a dicho nivel i, dentro de un nivel maximo relativo de LOC que podrían ser riesgosas al momento de mantener el software.

Img3 ** Figura XXX correspondiente al nivel máximo relativo de LOC que podrían ser riesgosas al momento de mantener el software


Duplicación: Se utiliza una medida que, aunque básica, debido a los estandares definidos para la realización de este proyecto, se hace más precisa. La técnica, descrita en 1*, consiste en contar los duplicados como un bloque de 6 líneas de código exáctamente iguales en una o varias partes del software. Luego, se harán medidas relativas al dividir la cantidad de líneas de código duplicadas por la cantidad total del software, clasificando el resultado en una de las categorías mostradas en la figura XXX.

Img4 ** Figura XXX Clasificación de duplicación de código

Volumen por unidad: 

En lo que concierne a la mantenibilidad de web services específicamente, se tomó de *2 aquellas medidas que pueden ayudar a medir la mantenibilidad en un sistema SOA hecho con web services. 

En 2*, basados en las definiciones de los documentos WSDL, los autores crean medidas de complejidad basados en la complejidad de los tipos de datos manejados, haciendo de estos un árbol formado por estructuras de datos simples y complejas. Cabe anotar que los tipos de datos complejos creados en el WSDL y puestos dentro de otro tipo de dato complejo hacen un sub-árbol, haciendo más complejo el tipo de dato que compone. La complejidad de un tipo de dato se mide por la profundidad del arbol que lo compone. Así, a continuación se explicarán las medidas utilizadas:

Métrica de complejidad basada en mensaje: Esta métrica busca medir la complejidad de los mensajes pasados de un servicio a otro haciendo una sumatoria de las complejidades de los tipos de datos utilizados en los mensajes, es decir: COMk = sum(ci) i=1 ; n
donde k es el k-ésimo mensaje, i es el tipo evaluado y n el número de tipos que utiliza el k-ésimo mensaje
Métrica de complejidad basada en operación: En esta métrica se busca medir la complejidad de una operación definida en el documento WSDL. Para ello se ha de tener en cuenta que las operaciones trabajan con mensajes de salida y de entranda. Por tanto, la métrica será la media de la complejidad de todos los mensajes de salida y entrada que estén definidos en la operación, esto es: CBO = (sum(COMi) i = 1 ; p + sum(COMo) j = 1; q)/m, donde p representa la cantidad de mensajes de entrada y q representa la cantidad de mensajes de salida de la operación. Asimismo, m representa la cantidad total de mensajes.
